---
title: Demystifying the Virtual DOM in Frontend Development
description: Demystifying the Virtual DOM in Frontend Development
date: 2025-07-07
isDraft: false
isFeatured: false
tags:
  - 'Test'
  - 'React'
thumbnail: './virtual-dom.png'
---

import { Image } from 'astro:assets'

import marekImg from '@/assets/images/marek.png'
import bigImg from '@/assets/images/test-big.png'

<Image
  src={marekImg}
  alt="Marecek kozi bobecek"
  priority
  width={marekImg.width / 2}
  densities={[2]}
  class="not-prose rounded-full"
/>

Frontend performance has always been a central concern when building scalable and responsive applications. One term that frequently arises when discussing modern JavaScript frameworks is the **Virtual DOM**. But what is it, and why has it become such a fundamental concept in libraries like React?

In this article, we will explore:

- What the DOM is and its limitations
- The problem the Virtual DOM solves
- How it works in practice
- A simplified implementation
- Pros and cons of using a Virtual DOM

---

## What is the DOM?

The **Document Object Model (DOM)** is a tree-like representation of the structure and content of a webpage. When HTML is parsed by the browser, it is turned into a live, interactive data structure — the DOM — which JavaScript can read and manipulate.

```html
<!-- An example of HTML structure -->
<div id="app">
  <h1>Hello World</h1>
  <p>This is a simple DOM example.</p>
</div>
```

This HTML would be turned into a nested structure that can be traversed and modified using JavaScript:

```js
const heading = document.querySelector('h1')
heading.textContent = 'Updated Heading'
```

However, manipulating the DOM can be **expensive**, especially in large applications where numerous elements might be updated frequently.

<Alert intent="tip">
  **DOM operations are slow** compared to JavaScript operations. This is because they
  cause browser reflows, repaints, and layout recalculations.
</Alert>

---

## What is the Virtual DOM?

The **Virtual DOM (VDOM)** is an abstraction over the real DOM. Instead of interacting with the DOM directly, you describe your UI in a declarative way, and a library takes care of translating that description into efficient DOM operations.

### Why Use a Virtual DOM?

The main reason is **performance** and **developer experience**. With the VDOM, you can:

1. Write declarative code without worrying about efficient DOM manipulation.
2. Avoid unnecessary reflows and repaints.
3. Enable fine-grained updates through efficient diffing algorithms.

---

## How It Works

At a high level, here's how the Virtual DOM works:

1. You define the UI as a tree of objects (often using JSX or hyperscript).
2. When the state changes, a new tree is created.
3. The library compares the new tree with the previous one.
4. It calculates the minimal set of DOM changes (called a **patch**).
5. The patch is applied to the real DOM.

Here’s a simplified example in pseudocode:

```js
function render(state) {
  return {
    type: 'div',
    props: { id: 'counter' },
    children: [
      { type: 'h1', props: {}, children: [`Count: ${state.count}`] },
      {
        type: 'button',
        props: { onclick: state.increment },
        children: ['Increment'],
      },
    ],
  }
}
```

The resulting object is a **Virtual DOM node**.

---

## A Tiny Virtual DOM Implementation

To better understand the concept, here’s a very simple VDOM renderer and patcher:

```js
function createElement(node) {
  if (typeof node === 'string') {
    return document.createTextNode(node)
  }

  const el = document.createElement(node.type)
  Object.entries(node.props || {}).forEach(([key, value]) => {
    el.setAttribute(key, value)
  })
  ;(node.children || []).forEach((child) => {
    el.appendChild(createElement(child))
  })

  return el
}
```

You could use this `createElement` function to mount a virtual node onto the real DOM. A full diffing algorithm would be significantly more complex, but this gives a glimpse into the power of abstraction.

---

## Pros and Cons of the Virtual DOM

### Advantages

- **Performance**: In many real-world cases, diffing virtual trees is faster than manipulating the real DOM directly.
- **Declarative APIs**: Developers focus on "what to render" rather than "how to render it".
- **Cross-platform**: Virtual DOMs can be used to target not just browsers, but native apps, terminals, and more.

### Disadvantages

- **Memory Overhead**: Holding a virtual tree in memory requires additional resources.
- **Initial Complexity**: Understanding and debugging VDOM-based updates can be harder for beginners.
- **Not Always Faster**: For simple apps or frequent massive updates, VDOM may not outperform direct DOM manipulation.

---

## Conclusion

The Virtual DOM is a clever abstraction that has enabled modern frontend libraries to build rich, performant UIs with a clean and maintainable codebase. While it's not a silver bullet, understanding how it works — and its trade-offs — will make you a more informed and capable frontend developer.

> "All abstractions are leaky, but some are worth it." – Joel Spolsky

---

## Images

<Image src={bigImg} alt="Ghibli landscape" width={960} densities={[1.5]} />

---

## Further Reading

- [React’s Reconciliation Algorithm](https://reactjs.org/docs/reconciliation.html)
- [Snabbdom Virtual DOM Library](https://github.com/snabbdom/snabbdom)
- [InfernoJS Performance Benchmarks](https://www.infernojs.org/)

---

### Final Tip

To experiment with these concepts yourself, try writing your own tiny VDOM from scratch. Even implementing a static version without diffing can be an eye-opening experience.
