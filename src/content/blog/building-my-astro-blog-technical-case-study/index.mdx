---
title: 'Building My Astro Blog: Technical Implementation Case Study'
description:
  'A technical case study of how I built my Astro blog. See how I implemented SEO,
  caching, OG images, RSS feeds, and more with detailed code examples from my actual site.'
date: 2025-11-05
isDraft: false
isFeatured: true
tags:
  - 'Astro'
  - 'Case Study'
  - 'SEO'
  - 'Performance'
thumbnail: './thumbnail.png'
---

import Link from '@/components/ui/Link.astro'
import { ENV } from '@/config/env'

import { CounterDemo } from './counter-demo'

## Introduction

In [Part 1: Why I Started Fresh](/blog/rebuilding-my-website-with-astro-why-and-results),
I shared why I rebuilt my website with Astro and the results I achieved. Now let's look at
how I actually built it.

This is a technical case study of my implementation - what I did, not what you should do.
These are the choices I made and why. Your needs might be different, but maybe you'll find
some useful patterns here.

I'll cover SEO setup, caching strategies, OG image generation, RSS feeds, analytics, and
more. All with detailed code examples from my actual site.

## Site Overview

This is a completely new site, not a migration. I started fresh and made different
choices. I kept TypeScript and Tailwind, but everything else changed: framework (Next.js →
Astro), hosting (Vercel → Cloudflare Workers), content approach (Sanity CMS → MDX &
Content Collections), and UI kit (custom components → DaisyUI).

## SEO

### Sitemap

Astro provides an official sitemap integration that is super simple to set up. I've
enabled it in production environment only. The whole solution looks like this:

```ts
// astro.config.ts
import sitemap from '@astrojs/sitemap'
import { defineConfig } from 'astro/config'
import { loadEnv } from 'vite'

const { ENV_NAME } = loadEnv(process.env.ENV_NAME!, process.cwd(), '')

export default defineConfig({
  integrations: [
    (ENV_NAME ?? 'staging') === 'production' && sitemap({ lastmod: new Date() }),
  ],
  // ... the rest of the astro.config
})
```

<Alert>
  This example reads environment variables in the Astro config. See [this
  section](https://docs.astro.build/en/guides/environment-variables/#in-the-astro-config-file)
  in the docs for more information.
</Alert>

### Self-referencing canonical tag

Super simple — it just reads `Astro.site` from `astro.config.*` and is used in the shared
layout `<head>`.

```astro
---
// CanonicalLink.astro
const canonicalUrl = new URL(Astro.url.pathname, Astro.site)
---

<link rel="canonical" href={canonicalUrl} />
```

### robots.txt

I made sure to disallow crawling my website or app in all environments except production.

```ts
// pages/robots.txt.ts
import type { APIRoute } from 'astro'

import { ENV } from '@/config/env'
import PRODUCTION_ROBOTS_TXT from '@/config/robots/production.robots.txt?raw'
import STAGING_ROBOTS_TXT from '@/config/robots/staging.robots.txt?raw'
import { ensureAstroSite } from '@/lib/utils/guards'

const SITEMAP_URL_PLACEHOLDER = '{{SITEMAP_URL}}'

const getSitemapUrl = (site: URL) => new URL('sitemap-index.xml', site).href

const injectSitemapUrl = (content: string, url: string) =>
  content.replace(SITEMAP_URL_PLACEHOLDER, url)

export const GET: APIRoute = ({ site }) => {
  const body = ENV.IS_PRODUCTION
    ? injectSitemapUrl(PRODUCTION_ROBOTS_TXT, getSitemapUrl(ensureAstroSite(site)))
    : STAGING_ROBOTS_TXT

  return new Response(body, {
    headers: {
      'content-type': 'text/plain; charset=utf-8',
    },
  })
}
```

In the code snippet above, I treat `robots.txt` as an API endpoint. It checks whether the
environment name is production and decides whether to return the robots.txt file that
allows or disallows crawling.

The site url is not hardcoded but it's injected in a place of a placeholder.

The production one:

```txt
User-agent: *
Disallow:

Sitemap: {{SITEMAP_URL}}
```

All other envs have crawling disallowed:

```txt
User-agent: *
Disallow: /
```

### Structured data

I decided to try [schema.org](https://schema.org/) structured data for the first time. Not
sure yet how much value it brings but the implementation was quite simple. I decided to
set it up just for articles since that is the main purpose of this website.

So I use three schema models — `WebSite`, `Person` and `BlogPosting`. You can see the full
definition
[here](https://github.com/marekh19/marekhonzal.com/blob/main/src/config/schemaJson.ts). It
allows me to pass all the dynamic parts from the articles into the `createBlogPostSchema`
function.

### Domain choice

I chose to use my full name for the domain. Using your full name helps your site rank
first when people search for you, strengthening your personal brand and credibility. It's
more effective than domains like _john.dev_ because _johndoe.com_ directly matches search
intent and signals personal authenticity. This was particularly important after my
previous domain didn't perform well in search results.

## Caching

Beyond SEO, performance was crucial. Since the old site struggled with Core Web Vitals, I
wanted a caching strategy that balances speed with freshness. I host this website on
Cloudflare Workers so I use the `_headers` file to define response headers for any
request.

I've split caching into four categories:

- **Immutable assets**: Files I can cache basically indefinitely like `.js` and `.css`
  files since these are always fingerprinted. Same for fonts. These are okay to be cached
  in the browser as well. In Astro, this is anything at `/_astro/*`.
- **Rarely changing assets**: All videos I embed in articles (cached for a week) and
  favicon + OG images (cached for 24 hours)
- **Often changing pages**: Homepage, blog page, projects page — all these pages include
  lists of projects and posts. If a new post comes out, I don't want to show a page
  without links to newly posted content. So I cache these pages on CDN level only for 10
  minutes and allow up to 24 hours of stale content while revalidating in the background.
- **Not so often changing pages**: All article and project detail pages. When these
  change, it's usually a small update. I cache them on CDN for an hour while serving stale
  content for up to 24 hours with background revalidation.

The headers look like this:

```txt
# Immutable assets
  Cache-Control: public, max-age=63072000, immutable

# Rarely changing assets
  Cache-Control: public, max-age=86400

# Homepage & list pages — short CDN TTL
  Cache-Control: public, max-age=0, s-maxage=600, stale-while-revalidate=86400

# Detail pages — longer CDN TTL
  Cache-Control: public, max-age=0, s-maxage=3600, stale-while-revalidate=86400
```

This allows for a good balance between aggressive caching and not serving stale content.

## OG Images generation

For social sharing, I wanted programmatic OG images so I wouldn't have to manually create
them for every post or project. When searching for a simple solution, I stumbled upon
[@vercel/og](https://www.npmjs.com/package/@vercel/og) library. It offers `ImageResponse`
constructor to create OG images with HTML and CSS. I decided to render it with _preact_
and _tailwind_ using the `h` function from preact. It uses
[Satori](https://github.com/vercel/satori#documentation) under the hood. Not all CSS
properties are supported, but for something simple like an OG image, it gets the job done.

I use two types of OG images:

- The generic base one with site name and description (homepage, blog, projects)
- Specific image with content injected from the resource (project detail, article
  detail) - has the name and description of the content

The implementation looks like this:

```ts
// src/pages/og/[slug].png.ts
type CollectionEntryItem = CollectionEntry<'blog' | 'projects'>

type OGAPIRoute = APIRoute<
  InferGetStaticPropsType<typeof getStaticPaths>,
  InferGetStaticParamsType<typeof getStaticPaths>
>

type OGHtmlData = Pick<CollectionEntryItem['data'], 'title' | 'description'>

const tintSvg = (svg: string, color: string) => {
  const tinted = svg.replace(/fill="currentColor"/gi, `fill="${color}"`)

  return `data:image/svg+xml;base64,${Buffer.from(tinted).toString('base64')}`
}

const generateHtml = (data: OGHtmlData): JSX.Element => {
  // Load avatar svg, tint it and inline it
  const rawSvg = fs.readFileSync(
    path.resolve(process.cwd(), 'src/assets/avatar.svg'),
    'utf8',
  )
  const svgDataUrl = tintSvg(rawSvg, '#f2f1f4')

  // All the html elements with `tw` prop to style them
  return h('div', {
    tw: 'h-full w-full bg-[#151219] flex items-center justify-start p-40',
    // ... the rest
    // NOTE: Can't use any css variables or tokens from the project, this is isolated context
  })
}

export const GET: OGAPIRoute = async ({ props }) => {
  const {
    item: { data },
  } = props

  // Load font files to be used in the OG image
  const loraRegular = fs.readFileSync(
    path.resolve(process.cwd(), 'public/fonts/lora-v36-latin-500.woff'),
  )

  const openSansRegular = fs.readFileSync(
    path.resolve(process.cwd(), 'public/fonts/open-sans-v43-latin-600.woff'),
  )

  const html = generateHtml(data)

  return new ImageResponse(html, {
    width: 1200,
    height: 630,
    fonts: [
      {
        name: 'Open Sans Semibold',
        data: openSansRegular.buffer,
        style: 'normal',
      },
      {
        name: 'Lora Medium',
        data: loraRegular.buffer,
        style: 'normal',
      },
    ],
  })
}

export const getStaticPaths = (async () => {
  const posts = await getCollection('blog', shouldIncludeItem)
  const projects = await getCollection('projects', shouldIncludeItem)

  // Generate all OG images at build time — `staticPageOgFallback` is the generic one.
  return [...posts, ...projects, staticPageOgFallback].map((item) => ({
    params: {
      slug: item.id,
    },
    props: { item },
  }))
}) satisfies GetStaticPaths
```

## RSS feed

To help readers discover new content, I added an RSS feed. Since this site is mostly about
the blog, I thought adding an RSS feed made sense. I decided to fill the feed with blog
posts only. Astro has a nice `@astrojs/rss` package that helps with the feed generation.
Similar to the OG image, it works as an API route with a static response that is
pre-generated at build time.

Thanks to Astro's handy library, it's very simple.

```ts
// src/pages/rss.xml.ts
export const GET: APIRoute = async ({ site }) => {
  // I don't care about the RSS feed in any other environment than production
  if (!ENV.IS_PRODUCTION) {
    return new Response(null, { status: 404, statusText: 'Not found' })
  }

  const posts = await getCollection('blog', shouldIncludeItem)
  const sortedPosts = getSortedContentByDateDesc(posts)

  return rss({
    trailingSlash: false,
    title: defaultSeo.baseTitle,
    description: defaultSeo.metaDescription,
    site: ensureAstroSite(site),
    items: sortedPosts.map((post) => ({
      title: post.data.title,
      pubDate: post.data.date,
      description: post.data.description,
      link: ROUTES.blog.post(post.id),
    })),
  })
}
```

I load the content collection I want, filter and sort it, then pass the desired values
into the `rss` function from `@astrojs/rss`.

## Analytics

I wanted lightweight analytics without the complexity and privacy concerns of traditional
tools. It would be overkill to use something like Google Analytics for a simple website,
and I didn't want to deal with cookie consents. I wanted something more privacy-oriented.

I've decided to try [Umami](https://umami.is/) which seems like the perfect choice. It
does everything I want. You can check the public
{<Link href={ENV.PUBLIC_UMAMI_SHARE_URL}>Analytics dashboard</Link>} of this site.

It has a nicely organized UI, the script is tiny (a little over 2kB), and it doesn't use
cookies.

## Interactivity - keep it simple

Astro's islands architecture is great, but I didn't want to overuse it. I developed a
simple philosophy for interactivity. When I think something should be interactive (like
animation or some kind of state), I use a mental checklist:

1. Could it be done with CSS only? _if not then_
2. Could it be done with simple vanilla JS only? (Well, anything can be, but whether it
   makes sense is another question.) _if not then_
3. Use Preact as a last resort

Currently the only thing I built with Preact is the list of available tags on the
[blog](/blog) page. It renders up to 5 tags, and if there are more, they're hidden by
default with a button to reveal them — just to avoid cluttering the UI visually. This
would work without Preact, but I decided to use it for the convenience of `useState`.

I find you rarely need something like a `motion` library. CSS keyframes will get you
pretty far. For super simple interactive elements, I just use vanilla JavaScript — like
the scroll progress bar or table of contents I used on article and project detail pages.

But I also did not want to limit myself. So whenever I want to sprinkle a bit of (p)react
I can. Like here below, I can just smash a bit of preact inside this article because it
uses MDX.

<center>
  <CounterDemo client:visible />
</center>

## A11y

Accessibility is important to me - I want the site to be usable for everyone. I always try
to aim for at least basic accessibility. Some rules of thumb from my experience.

- use semantic html elements like `<header>`, `<footer>`, `<main>`, `<time>`, `<figure>`
  and `<figcaption>`, `<article>`, `<aside>`, etc.
- check for contrast ratios (dev tools is your friend)
- Any interactive element without visible label must have either `aria-label` or something
  like `<span class="sr-only">label</span>`. Think any icon button.
- Respect reduced motion preference. There's a media query for that. If using Tailwind you
  can just prefix your transition classes with `motion-safe:`
- Ensure all interactive elements are accessible for keyboard navigation (with tab). And
  they have visible outline.
- Add "Skip links" — a button that is the very first tabbable element on the page that if
  you press, the focus is moved into the main part of the page (skip navigation links in
  the header etc.)
- Validate focus order and screen reader behavior with tool like
  [Silktide](https://silktide.com/) browser extension.

## Markdown as a component

One of Astro's strengths is its flexibility with content formats. I love that I can use
markdown and MDX anywhere in Astro. I can even use MDX components inside Astro components.
I used this for the [about](/#about) section of the homepage. The homepage is composed of
Astro components. But this one section is very "prose" heavy. It would be painful to write
and maintain this block of text as html elements. So I just wrote it as MDX component and
imported into Astro component.

```astro
---
// AboutSection.astro
// MDX component imported into Astro component
import AboutText from './AboutText.mdx'
---

<section aria-labelledby={sectionId} class={className}>
  <h2 id={sectionId}>A Bit About Me</h2>
  <AboutText />
  {/* The rest of the section... */}
</section>
```

This way whenever I want to update the text, I don't have to worry about manually adding
`<strong>` tags and passing classes to style them.

## Astro components with `cva`

For component styling variants, I wanted type safety without overcomplicating things. I
love using the [class-variance-authority](https://cva.style/) library. Whenever I need a
component with multiple variants, it provides a great developer experience. It's not
possible to use it directly inside `.astro` files, so I split the variants into a separate
`.ts` file and import it into the `.astro` component. Works like a charm. Here's a simple
example below.

```ts
// contentGridVariants.ts
import { cva, type VariantProps } from 'class-variance-authority'

export const contentGridVariants = cva(
  ['grid grid-cols-1 min-[600px]:grid-cols-2 gap-x-8 gap-y-12'],
  {
    variants: {
      type: {
        article: ['lg:grid-cols-3'],
        project: ['lg:grid-cols-1', 'lg:gap-y-8'],
      },
    },
    defaultVariants: { type: 'article' },
  },
)

export type ContentGridVariant = VariantProps<typeof contentGridVariants>
```

```astro
---
import { cn } from '@/lib/utils/cn'

import { contentGridVariants, type ContentGridVariant } from './contentGridVariants'

type Props = ContentGridVariant & {
  className?: string
}

const { type, className } = Astro.props
---

<div class={cn(contentGridVariants({ type }), className)}>
  <slot />
</div>
```

## Security headers

Finally, before launching, I wanted to ensure proper security headers. Before launching
any web app or website, I like to validate security headers. There's a nice tool by Snyk
aptly named [Security Headers](https://securityheaders.com/). You can scan any website and
it will give you a rank between **A** and **F**.

I always add _at least_ these.

| Header                       | Value                                                       |
| ---------------------------- | ----------------------------------------------------------- |
| `Referrer-Policy`            | `strict-origin-when-cross-origin`                           |
| `Strict-Transport-Security`  | `max-age=31536000; includeSubDomains`                       |
| `Content-Security-Policy`    | _As strict as possible, based on usage. But see note below_ |
| `Permissions-Policy`         | _Only those you need, forbid the rest_                      |
| `Cross-Origin-Opener-Policy` | `same-origin`                                               |
| `X-Frame-Options`            | `DENY`                                                      |
| `X-Content-Type-Options`     | `nosniff`                                                   |

<Alert title="Astro Islands and CSP">
  When using [Islands architecture](https://docs.astro.build/en/concepts/islands/) with
  Astro. You must add `script-src: unsafe-inline` to your **Content-Security-Policy**.
  Otherwise it won't work.

There's currently an
[experimental option](https://docs.astro.build/en/reference/experimental-flags/csp/) in
Astro config to enable hashes to avoid the `unsafe-inline` but I wasn't able to make it
work with my Cloudflare Workers deployment while not losing the option to set it globally
for everything else.

</Alert>

## Conclusion

These are the technical choices I made for my blog and how I implemented them. I'm sharing
what worked for me - your needs might be different, and that's okay.

What worked particularly well? Astro's content collections made MDX feel like a
first-class citizen, which was exactly what I wanted. The caching strategy on Cloudflare
Workers has been straightforward and effective. And programmatic OG images eliminated a
tedious manual step.

What surprised me? How little JavaScript I actually needed - most interactivity works fine
with CSS and vanilla JS. I also didn't expect structured data to be as simple as it was,
though I'm still not sure how much value it actually provides.

If I were doing it again, I might experiment with Astro's experimental CSP hashes feature
more, but the current setup works well. Overall, Astro gave me the flexibility to build
exactly what I needed without unnecessary complexity.

For the full story and results, see
[Part 1: Why I Started Fresh](/blog/rebuilding-my-website-with-astro-why-and-results).
