---
title: How I Rewrote My Website To Astro
description:
  I rewrote my website to Astro. My previous implementation used Next.js a headless CMS
  and was overall bloated. This time a focused on simplicity, performance and SEO. This
  time, it's really about the content.
date: 2025-10-24
isDraft: true
isFeatured: true
tags:
  - 'Astro'
thumbnail: './how-i-rewrote-my-website-to-astro.png'
---

import { Image } from 'astro:assets'

import Diagram from './diagram.svg'
import oldWebPerformanceImg from './old-web-performance.png'

## Introduction

This is a personal case study of how I rebuilt my own website - what I kept, what I threw
away, and why the new version feels so much better.

[The old site](https://old.marek.work) was built with Next.js, Sanity CMS, and the full
[Jamstack](https://jamstack.org) playbook. It looked solid on paper, but over time I
realized it didn't actually work for me. Short of three years later, I decided to start
fresh. This time the focus was on **simplicity, performance, and content**. The result is
a lean Astro-based site that does less but works better.

## The Next.js Era

When I built the first version of my website, Next.js 13 had just launched. React Server
Components were the new hot thing, and I wanted to try them out on a real project. Using a
headless CMS felt like the natural complement: it was decoupled, flexible, and made the
site feel professional. So I paired Next.js with Sanity CMS, added a webhook for on-demand
revalidation, and deployed to Vercel. Classic Jamstack.

[Incremental Static Regeneration](https://nextjs.org/docs/app/guides/incremental-static-regeneration#on-demand-revalidation-with-revalidatetag)
worked flawlessly. Sanity gave me a polished interface for managing content. For a while,
I was happy.

<Figure
  caption="The flow of on-demand ISR with Next.js and Sanity CMS"
  className="mx-auto max-w-md"
>
  <Diagram />
</Figure>

But cracks started to show. The project was born at a time when Next.js was evolving
rapidly, and upgrades were painful. Defaults around caching flipped back and forth, and
every major release felt like relearning the framework. Meanwhile, Sanity - while
technically solid - added friction. Editing content through a CMS UI just didn't motivate
me to write. I'm a developer; I prefer treating content as source code. I realized that
despite building all the infrastructure, I never wrote a single blog post.

Performance also took a hit. I couldn't resist adding a Three.js model of a mechanical
keyboard to the homepage-because why not show off my keyboard obsession? It looked cool
but tanked Core Web Vitals. And even with canonical tags in place, SEO was disappointing:
Google often indexed my Vercel preview URLs instead of the live site. Whether it was
domain authority, performance issues, or just Google's black box, the end result was that
my content barely surfaced in search.

<Figure caption="Terrible Core Web Vitals of the old web. Note that SEO score is lower because at the time of measurement the web already prevented indexing.">
  <Image
    src={oldWebPerformanceImg}
    alt="Old web core web vitals measurement result"
    widths={[360, 480, 720, 768, 960, 1024, 1280]}
    sizes="(max-width: 1023px) 100vw, 768px"
    class="not-prose rounded-md"
  />
</Figure>

## The Turning Point

After a couple of years, I looked at my site and asked: _what is this actually doing for
me?_ The answer was clear: not much. The CMS didn't encourage me to write. The site was
bloated with features I didn't use. And the complexity of keeping up with Next.js updates
drained motivation rather than sparked it.

When I finally decided to rewrite, I had two guiding principles:

- focus on the content
- keep everything as simple as possible

Astro was the obvious choice.

## The Astro Era

Astro approaches websites differently. It's static-first and ships zero JavaScript by
default, which means you start from a position of performance. When you need
interactivity, you add it explicitly through
[islands](https://docs.astro.build/en/concepts/islands/). Content lives in Markdown or
MDX, typed and validated through Astro's content collections. The build output is static
HTML, perfect for CDN caching.

Here's how the two versions of my site compare at a glance:

| Category               | Old Website           | New Website                 |
| ---------------------- | --------------------- | --------------------------- |
| **Framework**          | Next.js               | Astro                       |
| **Hosting**            | Vercel                | Cloudflare Workers          |
| **Styling**            | Tailwind CSS          | Tailwind CSS                |
| **UI Kit**             | Custom components     | DaisyUI                     |
| **Content**            | Sanity CMS            | MDX & Content Collections   |
| **Rendering strategy** | ISR with revalidation | Pure Static Generation      |
| **Interactivity**      | React                 | Preact throuh Astro islands |

Astro fit perfectly. It let me drop the CMS and just write MDX in my editor. It gave me
static HTML by default, with Preact islands where I needed a bit of client-side behavior.
And it shipped with thoughtful defaults: a sitemap, RSS feed, syntax highlighting with
Shiki, image optimization - all without extra setup. Deployment on Cloudflare Workers was
trivial.

## What Changed

The migration was surprisingly surgical. I kept TypeScript and Tailwind, but dropped
everything else: Sanity CMS, ISR complexity, and that performance-killing 3D keyboard. The
result? A sub-300 kB homepage with perfect Lighthouse scores and proper Google indexing.
More importantly, I finally feel motivated to write.

## How I approached some stuff

### SEO

#### Sitemap

Astro provides an official sitemap integration that is super simple to setup. I've enabled
it in production environment only. The whole solutions looks like this:

```ts
// astro.config.ts
import sitemap from '@astrojs/sitemap'
import { defineConfig } from 'astro/config'
import { loadEnv } from 'vite'

const { ENV_NAME } = loadEnv(process.env.ENV_NAME!, process.cwd(), '')

export default defineConfig({
  integrations: [
    (ENV_NAME ?? 'staging') === 'production' && sitemap({ lastmod: new Date() }),
  ],
  // ... the rest of the astro.config
})
```

<Alert>
  This example reads environment variables in the Astro config. See [this
  section](https://docs.astro.build/en/guides/environment-variables/#in-the-astro-config-file)
  in the docs for more information.
</Alert>

#### Self-referencing canonical tag

Super simple - just reads the `Astro.site` from `astro.config.*` file and used in the
shared layout in `<head>`.

```astro
---
// CanonicalLink.astro
const canonicalUrl = new URL(Astro.url.pathname, Astro.site)
---

<link rel="canonical" href={canonicalUrl} />
```

#### robots.txt

Always make sure to disallow crawling your website / app in all environments except
production.

```ts
// pages/robots.txt.ts
import type { APIRoute } from 'astro'

import { ENV } from '@/config/env'
import PRODUCTION_ROBOTS_TXT from '@/config/robots/production.robots.txt?raw'
import STAGING_ROBOTS_TXT from '@/config/robots/staging.robots.txt?raw'
import { ensureAstroSite } from '@/lib/utils/guards'

const SITEMAP_URL_PLACEHOLDER = '{{SITEMAP_URL}}'

const getSitemapUrl = (site: URL) => new URL('sitemap-index.xml', site).href

const injectSitemapUrl = (content: string, url: string) =>
  content.replace(SITEMAP_URL_PLACEHOLDER, url)

export const GET: APIRoute = ({ site }) => {
  const body = ENV.IS_PRODUCTION
    ? injectSitemapUrl(PRODUCTION_ROBOTS_TXT, getSitemapUrl(ensureAstroSite(site)))
    : STAGING_ROBOTS_TXT

  return new Response(body, {
    headers: {
      'content-type': 'text/plain; charset=utf-8',
    },
  })
}
```

In the code snippet above you can see we treat `robots.txt` as an API endpoint. It checks
whether the environment name is production and decides whether to return the robots.txt
file that allows or disallows crawling.

The site url is not hardcoded but it's injected in a place of a placeholder.

The production one:

```txt
User-agent: *
Disallow:

Sitemap: {{SITEMAP_URL}}
```

All other envs have crawling disallowed:

```txt
User-agent: *
Disallow: /
```

#### Structured data

I decided to try [schema.org](https://schema.org/) structured data for the first time. Not
sure yet how much value it brings but the implementation was quite simple. I decided to
set it up just for arcticles since that is the main purpose of this website.

So I use 3 schema models - `WebSite`, `Person` and `BlogPosting`. You can see the full
defition
[here](https://github.com/marekh19/marekhonzal.com/blob/main/src/config/schemaJson.ts). It
allows me to pass all the dynamic parts from the articles into the `createBlogPostSchema`
function.

#### Domain choice

Using your full name helps your site rank first when people search for you, strengthening
your personal brand and credibility. Itâ€™s more effective than domains like _john.dev_
because _johndoe.com_ directly matches search intent and signals personal authenticity.

### Caching

- snippets from `_headers file`
- explain immutable vs mutable

### OG Images generation

- show snippet how I did it - link to the file on github
- suggest `@vercel/og`

### RSS feed

- code snippet implementation
- prod only, articles only

### Analytics

- Umami - simple, lightweight, good ux
- no need for cookie consent
- does everything I need

### Interactivity (preact example)

- tags navigation snippet
- full preact + this solution is about 12kb of js

### A11y

- skip link
- respect reduced motion
- add focus outlines to all interactive elements
- check focus order and screen reader with Silktide or similar tool

### Visual stuff

- animations with CSS only (keyframes)
- tiny bits of vanilla js - scroll progress & table of contents

### Markdown as a component

- example of mdx used as astro component
- easier maintanance of prose text instead of html tags
- all of the bold text would have been wrapped in `<strong>` and maintanance is annoying

### Astro components with `cva`

- separate ts file that describes variants of the component and consume it in Astro file

### Security headers

- gotcha with CSP and astro islands
- validate against [Security Headers](https://securityheaders.com/)

## The result

- Google search for my name screenshot
- page speed insights screenshot of the website
- total size from cloudflare radar (uncompressed)

## Conclusion

Rebuilding my site with Astro wasn't just a framework swap. It was a reminder of why I
build personal websites in the first place: to write, to share, and to experiment. The old
Next.js + CMS stack gave me features I didn't need and friction I didn't want. Astro gave
me simplicity, speed, and a content-first workflow that matches how I actually work.

Astro isn't the right tool for every project-I wouldn't use it for a highly interactive
dashboard, for example. But for content-heavy, static-first websites, it's an absolute
joy. And if I were starting a new project today that combined a marketing site with an
internal app, I'd seriously consider a hybrid approach: Astro for the landing pages, a
React SPA for the app, and a shared component library in a monorepo.

The best part is that I finally feel motivated to publish. And at the end of the day,
that's the whole point.
