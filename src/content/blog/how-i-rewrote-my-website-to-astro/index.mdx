---
title: How I Rewrote My Website To Astro
description:
  I rewrote my website to Astro. My previous implementation used Next.js a headless CMS
  and was overall bloated. This time a focused on simplicity, performance and SEO. This
  time, it's really about the content.
date: 2025-10-24
isDraft: true
isFeatured: true
tags:
  - 'Astro'
thumbnail: './how-i-rewrote-my-website-to-astro.png'
---

import { Image } from 'astro:assets'

import Link from '@/components/ui/Link.astro'
import { ENV } from '@/config/env'

import { CounterDemo } from './counter-demo'
import Diagram from './diagram.svg'
import oldWebPerformanceImg from './old-web-performance.png'

## Introduction

This is a personal case study of how I rebuilt my own website - what I kept, what I threw
away, and why the new version feels so much better.

[The old site](https://old.marek.work) was built with Next.js, Sanity CMS, and the full
[Jamstack](https://jamstack.org) playbook. It looked solid on paper, but over time I
realized it didn't actually work for me. Short of three years later, I decided to start
fresh. This time the focus was on **simplicity, performance, and content**. The result is
a lean Astro-based site that does less but works better.

## The Next.js Era

When I built the first version of my website, Next.js 13 had just launched. React Server
Components were the new hot thing, and I wanted to try them out on a real project. Using a
headless CMS felt like the natural complement: it was decoupled, flexible, and made the
site feel professional. So I paired Next.js with Sanity CMS, added a webhook for on-demand
revalidation, and deployed to Vercel. Classic Jamstack.

[Incremental Static Regeneration](https://nextjs.org/docs/app/guides/incremental-static-regeneration#on-demand-revalidation-with-revalidatetag)
worked flawlessly. Sanity gave me a polished interface for managing content. For a while,
I was happy.

<Figure
  caption="The flow of on-demand ISR with Next.js and Sanity CMS"
  className="mx-auto max-w-md"
>
  <Diagram />
</Figure>

But cracks started to show. The project was born at a time when Next.js was evolving
rapidly, and upgrades were painful. Defaults around caching flipped back and forth, and
every major release felt like relearning the framework. Meanwhile, Sanity - while
technically solid - added friction. Editing content through a CMS UI just didn't motivate
me to write. I'm a developer; I prefer treating content as source code. I realized that
despite building all the infrastructure, I never wrote a single blog post.

Performance also took a hit. I couldn't resist adding a Three.js model of a mechanical
keyboard to the homepage-because why not show off my keyboard obsession? It looked cool
but tanked Core Web Vitals. And even with canonical tags in place, SEO was disappointing:
Google often indexed my Vercel preview URLs instead of the live site. Whether it was
domain authority, performance issues, or just Google's black box, the end result was that
my content barely surfaced in search.

<Figure caption="Terrible Core Web Vitals of the old web. Note that SEO score is lower because at the time of measurement the web already prevented indexing.">
  <Image
    src={oldWebPerformanceImg}
    alt="Old web core web vitals measurement result"
    widths={[360, 480, 720, 768, 960, 1024, 1280]}
    sizes="(max-width: 1023px) 100vw, 768px"
    class="not-prose rounded-md"
  />
</Figure>

## The Turning Point

After a couple of years, I looked at my site and asked: _what is this actually doing for
me?_ The answer was clear: not much. The CMS didn't encourage me to write. The site was
bloated with features I didn't use. And the complexity of keeping up with Next.js updates
drained motivation rather than sparked it.

When I finally decided to rewrite, I had two guiding principles:

- focus on the content
- keep everything as simple as possible

Astro was the obvious choice.

## The Astro Era

Astro approaches websites differently. It's static-first and ships zero JavaScript by
default, which means you start from a position of performance. When you need
interactivity, you add it explicitly through
[islands](https://docs.astro.build/en/concepts/islands/). Content lives in Markdown or
MDX, typed and validated through Astro's content collections. The build output is static
HTML, perfect for CDN caching.

Here's how the two versions of my site compare at a glance:

| Category               | Old Website           | New Website                 |
| ---------------------- | --------------------- | --------------------------- |
| **Framework**          | Next.js               | Astro                       |
| **Hosting**            | Vercel                | Cloudflare Workers          |
| **Styling**            | Tailwind CSS          | Tailwind CSS                |
| **UI Kit**             | Custom components     | DaisyUI                     |
| **Content**            | Sanity CMS            | MDX & Content Collections   |
| **Rendering strategy** | ISR with revalidation | Pure Static Generation      |
| **Interactivity**      | React                 | Preact throuh Astro islands |

Astro fit perfectly. It let me drop the CMS and just write MDX in my editor. It gave me
static HTML by default, with Preact islands where I needed a bit of client-side behavior.
And it shipped with thoughtful defaults: a sitemap, RSS feed, syntax highlighting with
Shiki, image optimization - all without extra setup. Deployment on Cloudflare Workers was
trivial.

## What Changed

The migration was surprisingly surgical. I kept TypeScript and Tailwind, but dropped
everything else: Sanity CMS, ISR complexity, and that performance-killing 3D keyboard. The
result? A sub-300 kB homepage with perfect Lighthouse scores and proper Google indexing.
More importantly, I finally feel motivated to write.

## How I approached some stuff

### SEO

#### Sitemap

Astro provides an official sitemap integration that is super simple to setup. I've enabled
it in production environment only. The whole solutions looks like this:

```ts
// astro.config.ts
import sitemap from '@astrojs/sitemap'
import { defineConfig } from 'astro/config'
import { loadEnv } from 'vite'

const { ENV_NAME } = loadEnv(process.env.ENV_NAME!, process.cwd(), '')

export default defineConfig({
  integrations: [
    (ENV_NAME ?? 'staging') === 'production' && sitemap({ lastmod: new Date() }),
  ],
  // ... the rest of the astro.config
})
```

<Alert>
  This example reads environment variables in the Astro config. See [this
  section](https://docs.astro.build/en/guides/environment-variables/#in-the-astro-config-file)
  in the docs for more information.
</Alert>

#### Self-referencing canonical tag

Super simple - just reads the `Astro.site` from `astro.config.*` file and used in the
shared layout in `<head>`.

```astro
---
// CanonicalLink.astro
const canonicalUrl = new URL(Astro.url.pathname, Astro.site)
---

<link rel="canonical" href={canonicalUrl} />
```

#### robots.txt

Always make sure to disallow crawling your website / app in all environments except
production.

```ts
// pages/robots.txt.ts
import type { APIRoute } from 'astro'

import { ENV } from '@/config/env'
import PRODUCTION_ROBOTS_TXT from '@/config/robots/production.robots.txt?raw'
import STAGING_ROBOTS_TXT from '@/config/robots/staging.robots.txt?raw'
import { ensureAstroSite } from '@/lib/utils/guards'

const SITEMAP_URL_PLACEHOLDER = '{{SITEMAP_URL}}'

const getSitemapUrl = (site: URL) => new URL('sitemap-index.xml', site).href

const injectSitemapUrl = (content: string, url: string) =>
  content.replace(SITEMAP_URL_PLACEHOLDER, url)

export const GET: APIRoute = ({ site }) => {
  const body = ENV.IS_PRODUCTION
    ? injectSitemapUrl(PRODUCTION_ROBOTS_TXT, getSitemapUrl(ensureAstroSite(site)))
    : STAGING_ROBOTS_TXT

  return new Response(body, {
    headers: {
      'content-type': 'text/plain; charset=utf-8',
    },
  })
}
```

In the code snippet above you can see we treat `robots.txt` as an API endpoint. It checks
whether the environment name is production and decides whether to return the robots.txt
file that allows or disallows crawling.

The site url is not hardcoded but it's injected in a place of a placeholder.

The production one:

```txt
User-agent: *
Disallow:

Sitemap: {{SITEMAP_URL}}
```

All other envs have crawling disallowed:

```txt
User-agent: *
Disallow: /
```

#### Structured data

I decided to try [schema.org](https://schema.org/) structured data for the first time. Not
sure yet how much value it brings but the implementation was quite simple. I decided to
set it up just for arcticles since that is the main purpose of this website.

So I use 3 schema models - `WebSite`, `Person` and `BlogPosting`. You can see the full
defition
[here](https://github.com/marekh19/marekhonzal.com/blob/main/src/config/schemaJson.ts). It
allows me to pass all the dynamic parts from the articles into the `createBlogPostSchema`
function.

#### Domain choice

Using your full name helps your site rank first when people search for you, strengthening
your personal brand and credibility. It’s more effective than domains like _john.dev_
because _johndoe.com_ directly matches search intent and signals personal authenticity.

### Caching

It's a good idea to leverage some decent **caching** strategy. I host this website on
Cloudflare Workers so I use the `_headers` file to define response headers for any
request.

I've split caching it into 4 categories:

- **Immutable assets**: Files we can cache basically indefinitely like `.js` and `.css`
  files since these are always fingerprinted. Same for fonts. These are okay to be cached
  in the browser as well. So in Astro website, it's anything at `/_astro/*`.
- **Rarely chaning assets**: All videos I embed in articles (cached for a week) and
  favicon + og images (cached for 24 hours)
- **Often changing pages**: Homepage, blog page, projects page - all these pages include
  lists of projects and posts. That means if a new post comes out, I don't want to show a
  page without links to newly posted content. Therefore I cache these pages on CDN level
  only for 10 minutes and allow up to 24 hours of stale content while revalidating in
  background:
- **Not so often changing pages**: All article and project detail pages. When these
  change, it's usually some kind of small update. Allow them to be cached on CDN for an
  hour while serving stale again for 24 hours with background revalidation.

The headers look like this:

```txt
# Immutable assets
  Cache-Control: public, max-age=63072000, immutable

# Rarely chaning assets
  Cache-Control: public, max-age=86400

# Homepage & list pages — short CDN TTL
  Cache-Control: public, max-age=0, s-maxage=600, stale-while-revalidate=86400

# Detail pages — longer CDN TTL
  Cache-Control: public, max-age=0, s-maxage=3600, stale-while-revalidate=86400
```

This allows for a good balance between aggressive caching and not serving stale content.

### OG Images generation

I wanted to aproach OG Images programmatically. Meaning I don't have to create them
manually in an image editor or something like that. When searching for a simple solution I
stumbled upon [@vercel/og](https://www.npmjs.com/package/@vercel/og) library. It offers
`ImageResponse` constructor to create your OG Image with html and css. I decided to render
it with _preact_ and _tailwind_ using the `h` function from preact. It uses
[Satori](https://github.com/vercel/satori#documentation) under the hood. Not all CSS
properties are supported but for something simple as OG image, it gets the job done.

I use 2 types of og images

- The generic base one with site name and description (homepage, blog, projects)
- Specific image with content injected from the resource (project detail, article
  detail) - has the name and description of the content

The implementation looks like this:

```ts
// src/pages/og/[slug].png.ts
type CollectionEntryItem = CollectionEntry<'blog' | 'projects'>

type OGAPIRoute = APIRoute<
  InferGetStaticPropsType<typeof getStaticPaths>,
  InferGetStaticParamsType<typeof getStaticPaths>
>

type OGHtmlData = Pick<CollectionEntryItem['data'], 'title' | 'description'>

const tintSvg = (svg: string, color: string) => {
  const tinted = svg.replace(/fill="currentColor"/gi, `fill="${color}"`)

  return `data:image/svg+xml;base64,${Buffer.from(tinted).toString('base64')}`
}

const generateHtml = (data: OGHtmlData): JSX.Element => {
  // Load avatar svg, tint it and inline it
  const rawSvg = fs.readFileSync(
    path.resolve(process.cwd(), 'src/assets/avatar.svg'),
    'utf8',
  )
  const svgDataUrl = tintSvg(rawSvg, '#f2f1f4')

  // All the html elements with `tw` prop to style them
  return h('div', {
    tw: 'h-full w-full bg-[#151219] flex items-center justify-start p-40',
    // ... the rest
    // NOTE: Can't use any css variables or tokens from the project, this is isolated context
  })
}

export const GET: OGAPIRoute = async ({ props }) => {
  const {
    item: { data },
  } = props

  // Load font files to be used in the OG image
  const loraRegular = fs.readFileSync(
    path.resolve(process.cwd(), 'public/fonts/lora-v36-latin-500.woff'),
  )

  const openSansRegular = fs.readFileSync(
    path.resolve(process.cwd(), 'public/fonts/open-sans-v43-latin-600.woff'),
  )

  const html = generateHtml(data)

  return new ImageResponse(html, {
    width: 1200,
    height: 630,
    fonts: [
      {
        name: 'Open Sans Semibold',
        data: openSansRegular.buffer,
        style: 'normal',
      },
      {
        name: 'Lora Medium',
        data: loraRegular.buffer,
        style: 'normal',
      },
    ],
  })
}

export const getStaticPaths = (async () => {
  const posts = await getCollection('blog', shouldIncludeItem)
  const projects = await getCollection('projects', shouldIncludeItem)

  // Generate all og images in build time - `staticPageOgFallback` is the generic one.
  return [...posts, ...projects, staticPageOgFallback].map((item) => ({
    params: {
      slug: item.id,
    },
    props: { item },
  }))
}) satisfies GetStaticPaths
```

### RSS feed

Since this site is mostly about the blog, I thought adding an rss feed makes sense. I
decided to fill the feed with blog posts only. Astro has a nice `@astrojs/rss` package
that helps with the feed generation. Similar as the og image, it works as an API route
with static response that is pre-generated in build time.

Thanks to astro's handy library, it's very simple.

```ts
// src/pages/rss.xml.ts
export const GET: APIRoute = async ({ site }) => {
  // I don't care about the rss feed in any other environment than production
  if (!ENV.IS_PRODUCTION) {
    return new Response(null, { status: 404, statusText: 'Not found' })
  }

  const posts = await getCollection('blog', shouldIncludeItem)
  const sortedPosts = getSortedContentByDateDesc(posts)

  return rss({
    trailingSlash: false,
    title: defaultSeo.baseTitle,
    description: defaultSeo.metaDescription,
    site: ensureAstroSite(site),
    items: sortedPosts.map((post) => ({
      title: post.data.title,
      pubDate: post.data.date,
      description: post.data.description,
      link: ROUTES.blog.post(post.id),
    })),
  })
}
```

We just load the content collection we want, filter and sort it and pass desired values
into the `rss` function from `@astrojs/rss`.

### Analytics

When you publish a website it's natural you want to know wheter at least someone ever
visits it. I wanted to try some more lightweight platform than Google Analytics. It would
not only be an overkill to use such a monstrous tool for a simple website, I also didn't
want to hassle with cookie consents and wanted something a bit more privacy oriented.

I've decided to try [Umami](https://umami.is/) which seems like the perfect choise. It
does everything I want. You can check the public
{<Link href={ENV.PUBLIC_UMAMI_SHARE_URL}>Analytics dashboard</Link>} of this site.

In my opinion it has very nicely organized UI, the script is tiny (a little over 2kB) and
doesn't use cookies.

### Interactivity - keep it simple

When I thought something should be interactive (think of animation or some kind of state).
I've used kind of mental checklist:

1. Could it be done with CSS only? _if not then_
2. Could it be done with simple vanilla JS only? (Well, anything can be, but whether it
   makes sense is another question.) _if not then_
3. Use a preact as last resort

Currently the only thing that is done with preact is the list of available tags on the
[blog](/blog) page. It renders up to 5 tags and if there's more, they are hidden by
default and you have to toggle a button to see them, just to not clutter the UI visually.
This would also work without preact, I decided to use it just for the convenience of
`useState`.

Remember you might not need something like `motion` library. CSS keyframes will get you
pretty far. Need some super simple interactive element? Just use JavaScript - like I used
on any article or project detail pages for the scroll progress bar or table of contents.

But I also did not want to limit myself. So whenever I want to sprinkle a bit of (p)react
I can. Like here below, I can just smash a bit of preact inside this article because it
uses MDX.

<center>
  <CounterDemo client:visible />
</center>

### A11y

I always try to aim for at least basic accessibility. Some rules of thumb from my
experience.

- use semantic html elements like `<header>`, `<footer>`, `<main>`, `<time>`, `<figure>`
  and `<figcaption>`, `<article>`, `<aside>`, etc.
- check for contrast ratios (dev tools is your friend)
- Any interactive element without visible label must have either `aria-label` or something
  like `<span class="sr-only">label</span>`. Think any icon button.
- Respect reduced motion preference. There's a media query for that. If using Tailwind you
  can just prefix your transition classes with `motion-safe:`
- Ensure all interactive elements are accessible for keyboard navigation (with tab). And
  they have visible outline.
- Add "Skip links" - a button that is the very first tabable element on the page that if
  you press, the focus is moved into the main part of the page (skip navigation links in
  the header etc.)
- Validate focus order and screen reader behavior with tool like
  [Silktide](https://silktide.com/) browser extension.

### Markdown as a component

I love the wide support for markdown and MDX anywhere in astro. You can even use MDX
components inside astro components. Let's have a look at the [about](/#about) section of
the homepage. The homepage is composed of Astro components. But this one section is very
"prose" heavy. It would be painful to write and maintain this block of text as html
elements. So I just wrote it as MDX component and imported into Astro component.

```astro
---
// AboutSection.astro
// MDX component imported into Astro component
import AboutText from './AboutText.mdx'
---

<section aria-labelledby={sectionId} class={className}>
  <h2 id={sectionId}>A Bit About Me</h2>
  <AboutText />
  {/* The rest of the section... */}
</section>
```

This way whenever I want to update the text, I don't have to worry about manually adding
`<strong>` tags and passing classes to style them.

### Astro components with `cva`

I love using the [class-variance-authority](https://cva.style/) library. Whenever doing
any component that has more kinds or variants, it's just great experience. It's not
possible to use it directly inside `.astro` file. But you can split the variants into a
separate `.ts` file and just import it into `.astro` component. Works like a charm. See
super simple example below.

```ts
// contentGridVariants.ts
import { cva, type VariantProps } from 'class-variance-authority'

export const contentGridVariants = cva(
  ['grid grid-cols-1 min-[600px]:grid-cols-2 gap-x-8 gap-y-12'],
  {
    variants: {
      type: {
        article: ['lg:grid-cols-3'],
        project: ['lg:grid-cols-1', 'lg:gap-y-8'],
      },
    },
    defaultVariants: { type: 'article' },
  },
)

export type ContentGridVariant = VariantProps<typeof contentGridVariants>
```

```astro
---
import { cn } from '@/lib/utils/cn'

import { contentGridVariants, type ContentGridVariant } from './contentGridVariants'

type Props = ContentGridVariant & {
  className?: string
}

const { type, className } = Astro.props
---

<div class={cn(contentGridVariants({ type }), className)}>
  <slot />
</div>
```

### Security headers

Before launching any web app / website I like to validate security headers. There's a nice
tool by snyk aptly named [Security Headers](https://securityheaders.com/). You can scan
any website and it will give you a rank between **A** and **F**.

I always add _at least_ these.

| Header                       | Value                                                       |
| ---------------------------- | ----------------------------------------------------------- |
| `Referrer-Policy`            | `strict-origin-when-cross-origin`                           |
| `Strict-Transport-Security`  | `nosniff`                                                   |
| `Content-Security-Policy`    | _As strict as possible, based on usage. But see note below_ |
| `Permissions-Policy`         | _Only those you need, forbid the rest_                      |
| `Cross-Origin-Opener-Policy` | `same-origin`                                               |
| `X-Frame-Options`            | `DENY`                                                      |
| `X-Content-Type-Options`     | `nosniff`                                                   |

<Alert title="Astro Islands and CSP">
  When using [Islands architecture](https://docs.astro.build/en/concepts/islands/) with
  Astro. You must add `script-src: unsafe-inline` to your **Content-Security-Policy**.
  Otherwise it won't work.

There's currently an
[experimental option](https://docs.astro.build/en/reference/experimental-flags/csp/) in
Astro config to enable hashes to avoid the `unsafe-inline` but I wasn't able to make it
work with my Cloudflare Workers deplyment while not losing the option to set it globally
for everything else.

</Alert>

<>
{/*

## The result

- Google search for my name screenshot
- page speed insights screenshot of the website
- total size from cloudflare radar (uncompressed)

\*/}

</>

## Conclusion

I hope this insight gave you at least a bit of valuable information I learnt while
experimenting with Astro. I must say I really enjoy working with it and it's now my
default choice for any static (or mostly static) site.

Astro isn't the right tool for every project-I wouldn't use it for a highly interactive
dashboard, for example. But for content-heavy, static-first websites, it's an absolute
joy. And if I were starting a new project today that combined a marketing site with an
internal app, I'd seriously consider a hybrid approach: Astro for the landing pages, a
React SPA for the app, and a shared component library in a monorepo.

The best part is that I finally feel motivated to publish. And at the end of the day,
that's the whole point.
